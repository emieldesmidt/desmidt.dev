<!DOCTYPE html>
<html>

<head>
  <script src="https://unpkg.com/konva@8.3.5/konva.min.js"></script>
  <meta charset="utf-8" />
  <title>Master the mind!</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #ffffff;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script>

    // stage and layer construction
    const width = window.innerWidth;
    const height = window.innerHeight;

    const stage = new Konva.Stage({
      container: 'container',
      width: width,
      height: height,
    });
    const layer = new Konva.Layer();

    stage.add(layer);

    // global variables
    const dot_radius = 20;
    const spacing = 65
    const dots = 4
    const colours = ['#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e']
    const snap_distance = 50

    let deck_positions = [...Array(dots).keys()].map(dot =>
    ({
      x: (stage.width() / 2) - ((spacing * dots) / 2) + (dot * spacing),
      y: stage.height() / 2,
      position: dot,
    }))


    /*
      HELPER METHODS
    */
    const shuffler = (array) => {
      return array.slice().sort(() => Math.random() - 0.5);
    }

    const snap = (x, y) => {
      const closest = deck_positions.reduce((a, b) => {
        return Math.hypot(a.x - x, a.y, y) < Math.hypot(b.x - x, b.y, y) ? a : b
      })
      return { x: closest.x, y: closest.y, position: closest.position, distance: Math.hypot(closest.x - x, closest.y - y) }
    }

    const check = (attempt, answer) => {
      let correct_col = 0
      let correct_pos = 0

      for (let i = 0; i < attempt.length; i++) {
        let attempt_i = attempt[i]
        let answer_i = answer[i]

        correct_pos += attempt_i === answer_i
        correct_col += answer.includes(attempt_i)
      }

      correct_col -= correct_pos
      return { correct_col: correct_col, correct_pos: correct_pos }
    }


    // game variables
    const answer = shuffler(colours.slice(0, 4))
    const ans_result = check(answer, answer)

    let previous_guesses = []
    let current_guess = [undefined, undefined, undefined, undefined]


    const draw_blank_row = () => {
      const blank_group = new Konva.Group()

      for (let dot = 0; dot < dots; dot++) {

        const circle = new Konva.Circle({
          x: deck_positions[dot].x,
          y: deck_positions[dot].y,
          radius: dot_radius,
          stroke: 'gray',
          strokeWidth: 1,
        });

        blank_group.add(circle)
      }

      const verify = new Konva.Circle({
        x: deck_positions[deck_positions.length - 1].x + spacing,
        y: deck_positions[deck_positions.length - 1].y,
        radius: dot_radius,
        stroke: 'gray',
        strokeWidth: 1,
        visible: false,
        id: 'verify_button',
      })
      verify.on('click', function () {
        console.log(check(current_guess, answer));
      });

      blank_group.add(verify)
      layer.add(blank_group)

    }

    const draw_colour_deck = () => {
      const columns = 4

      const deck_group = new Konva.Group()

      const x_offset = (stage.width() / 2) - 2 * spacing
      const y_offset = (stage.height() / 2) - 3 * spacing

      for (let colour = 0; colour < colours.length; colour++) {
        const x = (colour) % columns
        const y = Math.floor(colour / columns)

        const circle = new Konva.Circle({
          x: x_offset + x * spacing,
          y: y_offset + y * spacing,
          radius: dot_radius,
          fill: colours[colour],
        });

        circle.draggable(true)

        // check for a dot being positioned into a deck place
        circle.on('dragend', (e) => {
          const closest = snap(circle.x(), circle.y())

          if (closest.distance < snap_distance) {

            // move dot to the right position
            circle.position({
              x: closest.x,
              y: closest.y
            })

            current_guess[closest.position] = circle.fill()
          }

          // if all four dots are set, enable the check button
          let verify_button_visible = current_guess.filter(guess => guess != undefined).length == current_guess.length
          stage.find('#verify_button')[0].visible(verify_button_visible)
        })

        // check for a dot being positioned out of a deck place
        circle.on('dragstart', (e) => {
          const closest = snap(circle.x(), circle.y())

          if (closest.distance === 0)
            current_guess[closest.position] = undefined

        })

        deck_group.add(circle)
      }

      layer.add(deck_group)

    }



    const draw_previous_row = (colours, correct_pos, correct_col, row) => {

      const steps = 6
      const height = stage.height() / 2 + (row * spacing)

      const previous_guess_group = new Konva.Group()

      const x_positions = [...Array(steps).keys()].map(pos => (stage.width() / 2) - ((spacing * steps) / 2) + (pos * spacing))

      const correct_post_text = new Konva.Text({
        x: x_positions[0] - 15,
        y: height - 20,
        text: correct_pos,
        fontSize: 40,
        fontFamily: 'Calibri',
      })
      previous_guess_group.add(correct_post_text)

      for (let step = 0; step < steps - 2; step++) {
        const circle = new Konva.Circle({
          x: x_positions[step + 1],
          y: height,
          radius: dot_radius,
          fill: colours[step],
        });

        previous_guess_group.add(circle)
      }

      const correct_col_text = new Konva.Text({
        x: x_positions[5],
        y: height - 20,
        text: correct_col,
        fontSize: 40,
        fontFamily: 'Calibri',
      })

      previous_guess_group.add(correct_col_text)

      layer.add(previous_guess_group)
    }


    draw_blank_row()
    draw_colour_deck();

    previous_guesses.push({ colours: answer, correct_pos: ans_result.correct_pos, correct_col: ans_result.correct_col })

    previous_guesses.forEach((guess, index) => {
      draw_previous_row(guess.colours, guess.correct_pos, guess.correct_col, index + 1)
    })

  </script>
</body>

</html>