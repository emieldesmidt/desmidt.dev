<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Mastermind</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  const spacing = 65
  const colours = ['#cc0000', '#e69138', '#f1c232', '#6aa84f', '#45818e']

  let previous_guesses = []

  const shuffler = (array) => {
    return array.slice().sort( () => Math.random() - 0.5);
  }

  const resize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  resize()
  window.addEventListener('resize', resize)

  const draw_colour_deck = () => {
    const columns = 4

    const x_offset = (canvas.width / 2) - 2 * spacing
    const y_offset = (canvas.height / 2) - 3 * spacing

    for (let colour = 0; colour < colours.length; colour++) {
      const x = (colour) % columns
      const y = Math.floor(colour / columns)

      ctx.beginPath();
      ctx.arc(x_offset + x * spacing, y_offset + y * spacing, 20, 0, Math.PI*2, false);
      ctx.fillStyle = colours[colour]
      ctx.fill();
      ctx.closePath();
    }
  }
  
  const draw_blank_row = () => {
    ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
    
    const steps = 4

    const x_positions = [...Array(steps).keys()].map(pos => (canvas.width / 2) - ( (spacing * steps) / 2 ) + ( pos * spacing ))

    for (let step = 0; step < steps; step++) {
      ctx.beginPath();
      ctx.arc(x_positions[step], canvas.height / 2, 20, 0, Math.PI*2, false);
      ctx.stroke();
      ctx.closePath();
    }
  }

  const draw_previous_row = (colours, correct_pos, correct_col, row) => {
    
    const steps = 6
    const height = canvas.height / 2 + (row * spacing)

    x_positions = [...Array(steps).keys()].map(pos => (canvas.width / 2) - ( (spacing * steps) / 2 ) + ( pos * spacing ))

    ctx.fillStyle = 'gray'
    ctx.font = '40pt Calibri';
    ctx.fillText(correct_pos, x_positions[0]- 15, height + 15);

    for (let step = 0; step < steps - 2; step++) {
      ctx.beginPath();
      ctx.arc(x_positions[step + 1], height, 20, 0, Math.PI*2, false);
      ctx.fillStyle = colours[step]
      ctx.fill();
      ctx.closePath();
    }
    
    ctx.fillStyle = 'gray'
    ctx.fillText(correct_col, x_positions[5], height + 15);

  }

  const check = (attempt, answer) => {
    let correct_col = 0
    let correct_pos = 0

    for (var i = 0; i < attempt.length; i++) {
      let attempt_i = attempt[i]
      let answer_i = answer[i]

      correct_pos += attempt_i === answer_i
      correct_col += answer.includes(attempt_i)
    }

    correct_col -= correct_pos
    return {correct_col: correct_col, correct_pos: correct_pos}
  }

  console.log(colours)
  shu = shuffler(colours.slice(0, 3))
  result = check(shu, colours.slice(0, 3))

  draw_colour_deck();
  draw_blank_row()

  previous_guesses.push({colours: shu, correct_pos: result.correct_pos, correct_col: result.correct_col})

  previous_guesses.forEach((guess, index) => {
    draw_previous_row(guess.colours, guess.correct_pos, guess.correct_col, index + 1)
  })



</script>

</body>
</html>
